{"ast":null,"code":"import Platform from \"react-native-web/dist/exports/Platform\";\nimport color from 'color';\nimport { AdornmentSide, AdornmentType } from './Adornment/enums';\nimport { MIN_WIDTH, ADORNMENT_SIZE, MD2_ADORNMENT_OFFSET, MD2_AFFIX_OFFSET, MD2_FLAT_INPUT_OFFSET, MD2_ICON_OFFSET, MD2_INPUT_PADDING_HORIZONTAL, MD2_LABEL_PADDING_HORIZONTAL, MD2_LABEL_PADDING_TOP, MD2_MIN_HEIGHT, MD2_OUTLINED_INPUT_OFFSET, MD3_ADORNMENT_OFFSET, MD3_AFFIX_OFFSET, MD3_FLAT_INPUT_OFFSET, MD3_ICON_OFFSET, MD3_INPUT_PADDING_HORIZONTAL, MD3_LABEL_PADDING_HORIZONTAL, MD3_LABEL_PADDING_TOP, MD3_MIN_HEIGHT, MD3_OUTLINED_INPUT_OFFSET } from './constants';\nexport const calculateLabelTopPosition = (labelHeight, height = 0, optionalPadding = 0) => {\n  const customHeight = height > 0 ? height : 0;\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\nexport const calculateInputHeight = (labelHeight, height = 0, minHeight) => {\n  const finalHeight = height > 0 ? height : labelHeight;\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\nexport const calculatePadding = props => {\n  const {\n    height,\n    multiline = false\n  } = props;\n  let result = 0;\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n  return Math.max(0, result);\n};\nconst calculateTextAreaPadding = props => {\n  const {\n    dense\n  } = props;\n  return dense ? 10 : 20;\n};\nconst calculateInputPadding = ({\n  topPosition,\n  fontSize,\n  multiline,\n  scale,\n  dense,\n  offset,\n  isAndroid\n}) => {\n  const refFontSize = scale * fontSize;\n  let result = Math.floor(topPosition / 2);\n  result = result + Math.floor((refFontSize - fontSize) / 2) - (scale < 1 ? offset / 2 : 0);\n  if (multiline && isAndroid) result = Math.min(dense ? offset / 2 : offset, result);\n  return result;\n};\nexport const adjustPaddingOut = ({\n  pad,\n  multiline,\n  label,\n  scale,\n  height,\n  fontSize,\n  lineHeight,\n  dense,\n  offset,\n  isAndroid\n}) => {\n  const fontHeight = lineHeight ?? fontSize;\n  const refFontHeight = scale * fontSize;\n  let result = pad;\n  if (!isAndroid && height && !multiline) {\n    return {\n      paddingTop: Math.max(0, (height - fontHeight) / 2),\n      paddingBottom: Math.max(0, (height - fontHeight) / 2)\n    };\n  }\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight / 2 * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n    if (!dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight * scale) : Math.min(offset / 2, refFontHeight * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;\n      }\n    }\n    result = Math.floor(result);\n  }\n  return {\n    paddingTop: result,\n    paddingBottom: result\n  };\n};\nexport const adjustPaddingFlat = ({\n  pad,\n  scale,\n  multiline,\n  label,\n  height,\n  offset,\n  dense,\n  fontSize,\n  isAndroid,\n  styles\n}) => {\n  let result = pad;\n  let topResult = result;\n  let bottomResult = result;\n  const {\n    paddingTop,\n    paddingBottom\n  } = styles;\n  const refFontSize = scale * fontSize;\n  if (!multiline) {\n    if (label) {\n      return {\n        paddingTop,\n        paddingBottom\n      };\n    }\n    return {\n      paddingTop: result,\n      paddingBottom: result\n    };\n  }\n  if (label) {\n    topResult = paddingTop;\n    bottomResult = paddingBottom;\n    if (!isAndroid) {\n      if (dense) {\n        topResult += scale < 1 ? Math.min(result, refFontSize * scale) - result / 2 : Math.min(result, refFontSize * scale) - result / 2;\n      }\n      if (!dense) {\n        topResult += scale < 1 ? Math.min(offset / 2, refFontSize * scale) : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2)\n      };\n    }\n    if (!isAndroid) {\n      if (dense) {\n        result += scale < 1 ? Math.min(offset / 2, fontSize / 2 * scale) : Math.min(offset / 2, scale);\n      }\n      if (!dense) {\n        result += scale < 1 ? Math.min(offset, fontSize * scale) : Math.min(fontSize, offset / 2 * scale);\n      }\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult)\n  };\n};\nexport function calculateFlatAffixTopPosition({\n  height,\n  paddingTop,\n  paddingBottom,\n  affixHeight\n}) {\n  const inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n  const halfOfTheInputHeightDecreasedByAffixHeight = (inputHeightWithoutPadding - affixHeight) / 2;\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\nexport function calculateOutlinedIconAndAffixTopPosition({\n  height,\n  affixHeight,\n  labelYOffset\n}) {\n  return (height - affixHeight + labelYOffset) / 2;\n}\nexport const calculateFlatInputHorizontalPadding = ({\n  adornmentConfig,\n  isV3\n}) => {\n  const {\n    LABEL_PADDING_HORIZONTAL,\n    ADORNMENT_OFFSET,\n    FLAT_INPUT_OFFSET\n  } = getConstants(isV3);\n  let paddingLeft = LABEL_PADDING_HORIZONTAL;\n  let paddingRight = LABEL_PADDING_HORIZONTAL;\n  adornmentConfig.forEach(({\n    type,\n    side\n  }) => {\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n  return {\n    paddingLeft,\n    paddingRight\n  };\n};\nconst getInputTextColor = ({\n  theme,\n  textColor,\n  disabled\n}) => {\n  if (textColor) {\n    return textColor;\n  }\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n    return theme.colors.onSurface;\n  }\n  if (disabled) {\n    return color(theme.colors.text).alpha(0.54).rgb().string();\n  }\n  return theme.colors.text;\n};\nconst getActiveColor = ({\n  theme,\n  disabled,\n  error,\n  activeUnderlineColor,\n  activeOutlineColor,\n  mode\n}) => {\n  const isFlat = mode === 'flat';\n  const modeColor = isFlat ? activeUnderlineColor : activeOutlineColor;\n  if (error) {\n    return theme.colors.error;\n  }\n  if (modeColor) {\n    return modeColor;\n  }\n  if (disabled) {\n    if (theme.isV3) {\n      return theme.colors.onSurfaceDisabled;\n    }\n    return color(theme.colors.text).alpha(0.54).rgb().string();\n  }\n  return theme.colors.primary;\n};\nconst getPlaceholderColor = ({\n  theme,\n  disabled\n}) => {\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n    return theme.colors.onSurfaceVariant;\n  }\n  if (disabled) {\n    return theme.colors.disabled;\n  }\n  return theme.colors.placeholder;\n};\nconst getSelectionColor = ({\n  activeColor,\n  customSelectionColor\n}) => {\n  if (typeof customSelectionColor !== 'undefined') {\n    return customSelectionColor;\n  }\n  if (Platform.OS === 'android') {\n    return color(activeColor).alpha(0.54).rgb().string();\n  }\n  return activeColor;\n};\nconst getFlatBackgroundColor = ({\n  theme,\n  disabled\n}) => {\n  var _theme$colors, _theme$colors2;\n  if (theme.isV3) {\n    if (disabled) {\n      return color(theme.colors.onSurface).alpha(0.04).rgb().string();\n    } else {\n      return theme.colors.surfaceVariant;\n    }\n  }\n  if (disabled) {\n    return undefined;\n  }\n  return theme.dark ? color((_theme$colors = theme.colors) === null || _theme$colors === void 0 ? void 0 : _theme$colors.background).lighten(0.24).rgb().string() : color((_theme$colors2 = theme.colors) === null || _theme$colors2 === void 0 ? void 0 : _theme$colors2.background).darken(0.06).rgb().string();\n};\nconst getFlatUnderlineColor = ({\n  theme,\n  disabled,\n  underlineColor\n}) => {\n  if (!disabled && underlineColor) {\n    return underlineColor;\n  }\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n    return theme.colors.onSurfaceVariant;\n  }\n  if (disabled) {\n    return 'transparent';\n  }\n  return theme.colors.disabled;\n};\nconst getOutlinedOutlineInputColor = ({\n  theme,\n  disabled,\n  customOutlineColor\n}) => {\n  const isTransparent = color(customOutlineColor).alpha() === 0;\n  if (!disabled && customOutlineColor) {\n    return customOutlineColor;\n  }\n  if (theme.isV3) {\n    if (disabled) {\n      if (theme.dark) {\n        return 'transparent';\n      }\n      return theme.colors.surfaceDisabled;\n    }\n    return theme.colors.outline;\n  }\n  if (disabled) {\n    if (isTransparent) {\n      return customOutlineColor;\n    }\n    return theme.colors.disabled;\n  }\n  return theme.colors.placeholder;\n};\nexport const getFlatInputColors = ({\n  underlineColor,\n  activeUnderlineColor,\n  customSelectionColor,\n  textColor,\n  disabled,\n  error,\n  theme\n}) => {\n  const baseFlatColorProps = {\n    theme,\n    disabled\n  };\n  const activeColor = getActiveColor(Object.assign({}, baseFlatColorProps, {\n    error,\n    activeUnderlineColor,\n    mode: 'flat'\n  }));\n  return {\n    inputTextColor: getInputTextColor(Object.assign({}, baseFlatColorProps, {\n      textColor\n    })),\n    activeColor,\n    underlineColorCustom: getFlatUnderlineColor(Object.assign({}, baseFlatColorProps, {\n      underlineColor\n    })),\n    placeholderColor: getPlaceholderColor(baseFlatColorProps),\n    selectionColor: getSelectionColor({\n      activeColor,\n      customSelectionColor\n    }),\n    errorColor: theme.colors.error,\n    backgroundColor: getFlatBackgroundColor(baseFlatColorProps)\n  };\n};\nexport const getOutlinedInputColors = ({\n  activeOutlineColor,\n  customOutlineColor,\n  customSelectionColor,\n  textColor,\n  disabled,\n  error,\n  theme\n}) => {\n  const baseOutlinedColorProps = {\n    theme,\n    disabled\n  };\n  const activeColor = getActiveColor(Object.assign({}, baseOutlinedColorProps, {\n    error,\n    activeOutlineColor,\n    mode: 'outlined'\n  }));\n  return {\n    inputTextColor: getInputTextColor(Object.assign({}, baseOutlinedColorProps, {\n      textColor\n    })),\n    activeColor,\n    outlineColor: getOutlinedOutlineInputColor(Object.assign({}, baseOutlinedColorProps, {\n      customOutlineColor\n    })),\n    placeholderColor: getPlaceholderColor(baseOutlinedColorProps),\n    selectionColor: getSelectionColor({\n      activeColor,\n      customSelectionColor\n    }),\n    errorColor: theme.colors.error\n  };\n};\nexport const getConstants = isV3 => {\n  let AFFIX_OFFSET;\n  let ICON_OFFSET;\n  let LABEL_PADDING_TOP;\n  let LABEL_PADDING_HORIZONTAL;\n  let FLAT_INPUT_OFFSET;\n  let MIN_HEIGHT;\n  let INPUT_PADDING_HORIZONTAL;\n  let ADORNMENT_OFFSET;\n  let OUTLINED_INPUT_OFFSET;\n  if (isV3) {\n    AFFIX_OFFSET = MD3_AFFIX_OFFSET;\n    ICON_OFFSET = MD3_ICON_OFFSET;\n    LABEL_PADDING_TOP = MD3_LABEL_PADDING_TOP;\n    LABEL_PADDING_HORIZONTAL = MD3_LABEL_PADDING_HORIZONTAL;\n    FLAT_INPUT_OFFSET = MD3_FLAT_INPUT_OFFSET;\n    MIN_HEIGHT = MD3_MIN_HEIGHT;\n    INPUT_PADDING_HORIZONTAL = MD3_INPUT_PADDING_HORIZONTAL;\n    ADORNMENT_OFFSET = MD3_ADORNMENT_OFFSET;\n    OUTLINED_INPUT_OFFSET = MD3_OUTLINED_INPUT_OFFSET;\n  } else {\n    AFFIX_OFFSET = MD2_AFFIX_OFFSET;\n    ICON_OFFSET = MD2_ICON_OFFSET;\n    LABEL_PADDING_TOP = MD2_LABEL_PADDING_TOP;\n    LABEL_PADDING_HORIZONTAL = MD2_LABEL_PADDING_HORIZONTAL;\n    FLAT_INPUT_OFFSET = MD2_FLAT_INPUT_OFFSET;\n    MIN_HEIGHT = MD2_MIN_HEIGHT;\n    INPUT_PADDING_HORIZONTAL = MD2_INPUT_PADDING_HORIZONTAL;\n    ADORNMENT_OFFSET = MD2_ADORNMENT_OFFSET;\n    OUTLINED_INPUT_OFFSET = MD2_OUTLINED_INPUT_OFFSET;\n  }\n  return {\n    AFFIX_OFFSET,\n    ICON_OFFSET,\n    LABEL_PADDING_TOP,\n    LABEL_PADDING_HORIZONTAL,\n    FLAT_INPUT_OFFSET,\n    MIN_HEIGHT,\n    INPUT_PADDING_HORIZONTAL,\n    ADORNMENT_OFFSET,\n    OUTLINED_INPUT_OFFSET,\n    MIN_WIDTH\n  };\n};","map":{"version":3,"names":["color","AdornmentSide","AdornmentType","MIN_WIDTH","ADORNMENT_SIZE","MD2_ADORNMENT_OFFSET","MD2_AFFIX_OFFSET","MD2_FLAT_INPUT_OFFSET","MD2_ICON_OFFSET","MD2_INPUT_PADDING_HORIZONTAL","MD2_LABEL_PADDING_HORIZONTAL","MD2_LABEL_PADDING_TOP","MD2_MIN_HEIGHT","MD2_OUTLINED_INPUT_OFFSET","MD3_ADORNMENT_OFFSET","MD3_AFFIX_OFFSET","MD3_FLAT_INPUT_OFFSET","MD3_ICON_OFFSET","MD3_INPUT_PADDING_HORIZONTAL","MD3_LABEL_PADDING_HORIZONTAL","MD3_LABEL_PADDING_TOP","MD3_MIN_HEIGHT","MD3_OUTLINED_INPUT_OFFSET","calculateLabelTopPosition","labelHeight","height","optionalPadding","customHeight","Math","floor","calculateInputHeight","minHeight","finalHeight","calculatePadding","props","multiline","result","calculateTextAreaPadding","calculateInputPadding","max","dense","topPosition","fontSize","scale","offset","isAndroid","refFontSize","min","adjustPaddingOut","pad","label","lineHeight","fontHeight","refFontHeight","paddingTop","paddingBottom","adjustPaddingFlat","styles","topResult","bottomResult","calculateFlatAffixTopPosition","affixHeight","inputHeightWithoutPadding","halfOfTheInputHeightDecreasedByAffixHeight","calculateOutlinedIconAndAffixTopPosition","labelYOffset","calculateFlatInputHorizontalPadding","adornmentConfig","isV3","LABEL_PADDING_HORIZONTAL","ADORNMENT_OFFSET","FLAT_INPUT_OFFSET","getConstants","paddingLeft","paddingRight","forEach","type","side","Icon","Left","Right","Affix","getInputTextColor","theme","textColor","disabled","colors","onSurfaceDisabled","onSurface","text","alpha","rgb","string","getActiveColor","error","activeUnderlineColor","activeOutlineColor","mode","isFlat","modeColor","primary","getPlaceholderColor","onSurfaceVariant","placeholder","getSelectionColor","activeColor","customSelectionColor","Platform","OS","getFlatBackgroundColor","_theme$colors","_theme$colors2","surfaceVariant","undefined","dark","background","lighten","darken","getFlatUnderlineColor","underlineColor","getOutlinedOutlineInputColor","customOutlineColor","isTransparent","surfaceDisabled","outline","getFlatInputColors","baseFlatColorProps","Object","assign","inputTextColor","underlineColorCustom","placeholderColor","selectionColor","errorColor","backgroundColor","getOutlinedInputColors","baseOutlinedColorProps","outlineColor","AFFIX_OFFSET","ICON_OFFSET","LABEL_PADDING_TOP","MIN_HEIGHT","INPUT_PADDING_HORIZONTAL","OUTLINED_INPUT_OFFSET"],"sources":["C:\\Users\\robin\\Documents\\RpgHybrid\\node_modules\\react-native-paper\\src\\components\\TextInput\\helpers.tsx"],"sourcesContent":["import { Platform } from 'react-native';\n\nimport color from 'color';\n\nimport { AdornmentSide, AdornmentType } from './Adornment/enums';\nimport type { AdornmentConfig } from './Adornment/types';\nimport {\n  MIN_WIDTH,\n  ADORNMENT_SIZE,\n  MD2_ADORNMENT_OFFSET,\n  MD2_AFFIX_OFFSET,\n  MD2_FLAT_INPUT_OFFSET,\n  MD2_ICON_OFFSET,\n  MD2_INPUT_PADDING_HORIZONTAL,\n  MD2_LABEL_PADDING_HORIZONTAL,\n  MD2_LABEL_PADDING_TOP,\n  MD2_MIN_HEIGHT,\n  MD2_OUTLINED_INPUT_OFFSET,\n  MD3_ADORNMENT_OFFSET,\n  MD3_AFFIX_OFFSET,\n  MD3_FLAT_INPUT_OFFSET,\n  MD3_ICON_OFFSET,\n  MD3_INPUT_PADDING_HORIZONTAL,\n  MD3_LABEL_PADDING_HORIZONTAL,\n  MD3_LABEL_PADDING_TOP,\n  MD3_MIN_HEIGHT,\n  MD3_OUTLINED_INPUT_OFFSET,\n} from './constants';\nimport type { TextInputLabelProp } from './types';\nimport type { InternalTheme } from '../../types';\n\ntype PaddingProps = {\n  height: number | null;\n  labelHalfHeight: number;\n  multiline: boolean | null;\n  dense: boolean | null;\n  topPosition: number;\n  fontSize: number;\n  lineHeight?: number;\n  label?: TextInputLabelProp | null;\n  scale: number;\n  offset: number;\n  isAndroid: boolean;\n  styles: { paddingTop: number; paddingBottom: number };\n};\n\ntype AdjProps = PaddingProps & {\n  pad: number;\n};\n\nexport type Padding = { paddingTop: number; paddingBottom: number };\n\nexport const calculateLabelTopPosition = (\n  labelHeight: number,\n  height: number = 0,\n  optionalPadding: number = 0\n): number => {\n  const customHeight = height > 0 ? height : 0;\n\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\n\nexport const calculateInputHeight = (\n  labelHeight: number,\n  height: any = 0,\n  minHeight: number\n): number => {\n  const finalHeight = height > 0 ? height : labelHeight;\n\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\n\nexport const calculatePadding = (props: PaddingProps): number => {\n  const { height, multiline = false } = props;\n\n  let result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nconst calculateTextAreaPadding = (props: PaddingProps) => {\n  const { dense } = props;\n\n  return dense ? 10 : 20;\n};\n\nconst calculateInputPadding = ({\n  topPosition,\n  fontSize,\n  multiline,\n  scale,\n  dense,\n  offset,\n  isAndroid,\n}: PaddingProps): number => {\n  const refFontSize = scale * fontSize;\n  let result = Math.floor(topPosition / 2);\n\n  result =\n    result +\n    Math.floor((refFontSize - fontSize) / 2) -\n    (scale < 1 ? offset / 2 : 0);\n\n  if (multiline && isAndroid)\n    result = Math.min(dense ? offset / 2 : offset, result);\n\n  return result;\n};\n\nexport const adjustPaddingOut = ({\n  pad,\n  multiline,\n  label,\n  scale,\n  height,\n  fontSize,\n  lineHeight,\n  dense,\n  offset,\n  isAndroid,\n}: AdjProps): Padding => {\n  const fontHeight = lineHeight ?? fontSize;\n  const refFontHeight = scale * fontSize;\n  let result = pad;\n\n  if (!isAndroid && height && !multiline) {\n    return {\n      paddingTop: Math.max(0, (height - fontHeight) / 2),\n      paddingBottom: Math.max(0, (height - fontHeight) / 2),\n    };\n  }\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, (refFontHeight / 2) * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n    if (!dense) {\n      if (label) {\n        result +=\n          scale < 1\n            ? Math.min(offset, refFontHeight * scale)\n            : Math.min(offset / 2, refFontHeight * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;\n      }\n    }\n    result = Math.floor(result);\n  }\n  return { paddingTop: result, paddingBottom: result };\n};\n\nexport const adjustPaddingFlat = ({\n  pad,\n  scale,\n  multiline,\n  label,\n  height,\n  offset,\n  dense,\n  fontSize,\n  isAndroid,\n  styles,\n}: AdjProps): Padding => {\n  let result = pad;\n  let topResult = result;\n  let bottomResult = result;\n  const { paddingTop, paddingBottom } = styles;\n  const refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    // do not modify padding if input is not multiline\n    if (label) {\n      // return const style for flat input with label\n      return { paddingTop, paddingBottom };\n    }\n    // return pad for flat input without label\n    return { paddingTop: result, paddingBottom: result };\n  }\n\n  if (label) {\n    // add paddings passed from styles\n    topResult = paddingTop;\n    bottomResult = paddingBottom;\n\n    // adjust top padding for iOS\n    if (!isAndroid) {\n      if (dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(result, refFontSize * scale) - result / 2\n            : Math.min(result, refFontSize * scale) - result / 2;\n      }\n      if (!dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(offset / 2, refFontSize * scale)\n            : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      // center text when height is passed\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2),\n      };\n    }\n    // adjust paddings for iOS if no label\n    if (!isAndroid) {\n      if (dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset / 2, (fontSize / 2) * scale)\n            : Math.min(offset / 2, scale);\n      }\n      if (!dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset, fontSize * scale)\n            : Math.min(fontSize, (offset / 2) * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult),\n  };\n};\n\nexport function calculateFlatAffixTopPosition({\n  height,\n  paddingTop,\n  paddingBottom,\n  affixHeight,\n}: {\n  height: number;\n  paddingTop: number;\n  paddingBottom: number;\n  affixHeight: number;\n}): number {\n  const inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n\n  const halfOfTheInputHeightDecreasedByAffixHeight =\n    (inputHeightWithoutPadding - affixHeight) / 2;\n\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\n\nexport function calculateOutlinedIconAndAffixTopPosition({\n  height,\n  affixHeight,\n  labelYOffset,\n}: {\n  height: number;\n  affixHeight: number;\n  labelYOffset: number;\n}): number {\n  return (height - affixHeight + labelYOffset) / 2;\n}\n\nexport const calculateFlatInputHorizontalPadding = ({\n  adornmentConfig,\n  isV3,\n}: {\n  adornmentConfig: AdornmentConfig[];\n  isV3?: boolean;\n}) => {\n  const { LABEL_PADDING_HORIZONTAL, ADORNMENT_OFFSET, FLAT_INPUT_OFFSET } =\n    getConstants(isV3);\n\n  let paddingLeft = LABEL_PADDING_HORIZONTAL;\n  let paddingRight = LABEL_PADDING_HORIZONTAL;\n\n  adornmentConfig.forEach(({ type, side }) => {\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n\n  return { paddingLeft, paddingRight };\n};\n\ntype BaseProps = {\n  theme: InternalTheme;\n  disabled?: boolean;\n};\n\ntype Mode = 'flat' | 'outlined';\n\nconst getInputTextColor = ({\n  theme,\n  textColor,\n  disabled,\n}: BaseProps & { textColor?: string }) => {\n  if (textColor) {\n    return textColor;\n  }\n\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    return theme.colors.onSurface;\n  }\n\n  if (disabled) {\n    return color(theme.colors.text).alpha(0.54).rgb().string();\n  }\n\n  return theme.colors.text;\n};\n\nconst getActiveColor = ({\n  theme,\n  disabled,\n  error,\n  activeUnderlineColor,\n  activeOutlineColor,\n  mode,\n}: BaseProps & {\n  error?: boolean;\n  activeUnderlineColor?: string;\n  activeOutlineColor?: string;\n  mode?: Mode;\n}) => {\n  const isFlat = mode === 'flat';\n  const modeColor = isFlat ? activeUnderlineColor : activeOutlineColor;\n\n  if (error) {\n    return theme.colors.error;\n  }\n\n  if (modeColor) {\n    return modeColor;\n  }\n\n  if (disabled) {\n    if (theme.isV3) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    return color(theme.colors.text).alpha(0.54).rgb().string();\n  }\n\n  return theme.colors.primary;\n};\n\nconst getPlaceholderColor = ({ theme, disabled }: BaseProps) => {\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    return theme.colors.onSurfaceVariant;\n  }\n\n  if (disabled) {\n    return theme.colors.disabled;\n  }\n\n  return theme.colors.placeholder;\n};\n\nconst getSelectionColor = ({\n  activeColor,\n  customSelectionColor,\n}: {\n  activeColor: string;\n  customSelectionColor?: string;\n}) => {\n  if (typeof customSelectionColor !== 'undefined') {\n    return customSelectionColor;\n  }\n\n  if (Platform.OS === 'android') {\n    return color(activeColor).alpha(0.54).rgb().string();\n  }\n\n  return activeColor;\n};\n\nconst getFlatBackgroundColor = ({ theme, disabled }: BaseProps) => {\n  if (theme.isV3) {\n    if (disabled) {\n      return color(theme.colors.onSurface).alpha(0.04).rgb().string();\n    } else {\n      return theme.colors.surfaceVariant;\n    }\n  }\n\n  if (disabled) {\n    return undefined;\n  }\n\n  return theme.dark\n    ? color(theme.colors?.background).lighten(0.24).rgb().string()\n    : color(theme.colors?.background).darken(0.06).rgb().string();\n};\n\nconst getFlatUnderlineColor = ({\n  theme,\n  disabled,\n  underlineColor,\n}: BaseProps & { underlineColor?: string }) => {\n  if (!disabled && underlineColor) {\n    return underlineColor;\n  }\n\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    return theme.colors.onSurfaceVariant;\n  }\n\n  if (disabled) {\n    return 'transparent';\n  }\n\n  return theme.colors.disabled;\n};\n\nconst getOutlinedOutlineInputColor = ({\n  theme,\n  disabled,\n  customOutlineColor,\n}: BaseProps & { customOutlineColor?: string }) => {\n  const isTransparent = color(customOutlineColor).alpha() === 0;\n\n  if (!disabled && customOutlineColor) {\n    return customOutlineColor;\n  }\n\n  if (theme.isV3) {\n    if (disabled) {\n      if (theme.dark) {\n        return 'transparent';\n      }\n      return theme.colors.surfaceDisabled;\n    }\n\n    return theme.colors.outline;\n  }\n\n  if (disabled) {\n    if (isTransparent) {\n      return customOutlineColor;\n    }\n    return theme.colors.disabled;\n  }\n  return theme.colors.placeholder;\n};\n\nexport const getFlatInputColors = ({\n  underlineColor,\n  activeUnderlineColor,\n  customSelectionColor,\n  textColor,\n  disabled,\n  error,\n  theme,\n}: {\n  underlineColor?: string;\n  activeUnderlineColor?: string;\n  customSelectionColor?: string;\n  textColor?: string;\n  disabled?: boolean;\n  error?: boolean;\n  theme: InternalTheme;\n}) => {\n  const baseFlatColorProps = { theme, disabled };\n  const activeColor = getActiveColor({\n    ...baseFlatColorProps,\n    error,\n    activeUnderlineColor,\n    mode: 'flat',\n  });\n\n  return {\n    inputTextColor: getInputTextColor({\n      ...baseFlatColorProps,\n      textColor,\n    }),\n    activeColor,\n    underlineColorCustom: getFlatUnderlineColor({\n      ...baseFlatColorProps,\n      underlineColor,\n    }),\n    placeholderColor: getPlaceholderColor(baseFlatColorProps),\n    selectionColor: getSelectionColor({ activeColor, customSelectionColor }),\n    errorColor: theme.colors.error,\n    backgroundColor: getFlatBackgroundColor(baseFlatColorProps),\n  };\n};\n\nexport const getOutlinedInputColors = ({\n  activeOutlineColor,\n  customOutlineColor,\n  customSelectionColor,\n  textColor,\n  disabled,\n  error,\n  theme,\n}: {\n  activeOutlineColor?: string;\n  customOutlineColor?: string;\n  customSelectionColor?: string;\n  textColor?: string;\n  disabled?: boolean;\n  error?: boolean;\n  theme: InternalTheme;\n}) => {\n  const baseOutlinedColorProps = { theme, disabled };\n  const activeColor = getActiveColor({\n    ...baseOutlinedColorProps,\n    error,\n    activeOutlineColor,\n    mode: 'outlined',\n  });\n\n  return {\n    inputTextColor: getInputTextColor({\n      ...baseOutlinedColorProps,\n      textColor,\n    }),\n    activeColor,\n    outlineColor: getOutlinedOutlineInputColor({\n      ...baseOutlinedColorProps,\n      customOutlineColor,\n    }),\n    placeholderColor: getPlaceholderColor(baseOutlinedColorProps),\n    selectionColor: getSelectionColor({ activeColor, customSelectionColor }),\n    errorColor: theme.colors.error,\n  };\n};\n\nexport const getConstants = (isV3?: boolean) => {\n  // Text input affix\n  let AFFIX_OFFSET;\n  // Text input icon\n  let ICON_OFFSET;\n  //Text input flat\n  let LABEL_PADDING_TOP;\n  let LABEL_PADDING_HORIZONTAL;\n  let FLAT_INPUT_OFFSET;\n  let MIN_HEIGHT;\n  // Text input outlined;\n  let INPUT_PADDING_HORIZONTAL;\n  let ADORNMENT_OFFSET;\n  let OUTLINED_INPUT_OFFSET;\n\n  if (isV3) {\n    AFFIX_OFFSET = MD3_AFFIX_OFFSET;\n    ICON_OFFSET = MD3_ICON_OFFSET;\n    LABEL_PADDING_TOP = MD3_LABEL_PADDING_TOP;\n    LABEL_PADDING_HORIZONTAL = MD3_LABEL_PADDING_HORIZONTAL;\n    FLAT_INPUT_OFFSET = MD3_FLAT_INPUT_OFFSET;\n    MIN_HEIGHT = MD3_MIN_HEIGHT;\n    INPUT_PADDING_HORIZONTAL = MD3_INPUT_PADDING_HORIZONTAL;\n    ADORNMENT_OFFSET = MD3_ADORNMENT_OFFSET;\n    OUTLINED_INPUT_OFFSET = MD3_OUTLINED_INPUT_OFFSET;\n  } else {\n    AFFIX_OFFSET = MD2_AFFIX_OFFSET;\n    ICON_OFFSET = MD2_ICON_OFFSET;\n    LABEL_PADDING_TOP = MD2_LABEL_PADDING_TOP;\n    LABEL_PADDING_HORIZONTAL = MD2_LABEL_PADDING_HORIZONTAL;\n    FLAT_INPUT_OFFSET = MD2_FLAT_INPUT_OFFSET;\n    MIN_HEIGHT = MD2_MIN_HEIGHT;\n    INPUT_PADDING_HORIZONTAL = MD2_INPUT_PADDING_HORIZONTAL;\n    ADORNMENT_OFFSET = MD2_ADORNMENT_OFFSET;\n    OUTLINED_INPUT_OFFSET = MD2_OUTLINED_INPUT_OFFSET;\n  }\n\n  return {\n    AFFIX_OFFSET,\n    ICON_OFFSET,\n    LABEL_PADDING_TOP,\n    LABEL_PADDING_HORIZONTAL,\n    FLAT_INPUT_OFFSET,\n    MIN_HEIGHT,\n    INPUT_PADDING_HORIZONTAL,\n    ADORNMENT_OFFSET,\n    OUTLINED_INPUT_OFFSET,\n    MIN_WIDTH,\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}