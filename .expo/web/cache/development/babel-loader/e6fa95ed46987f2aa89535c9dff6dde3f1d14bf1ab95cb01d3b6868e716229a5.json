{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\robin\\\\Documents\\\\RpgHybrid\\\\src\\\\contexts\\\\WorkoutContext.js\";\nimport React, { createContext, useContext, useState } from 'react';\nimport { doc, addDoc, collection, updateDoc, getDoc, setDoc, arrayUnion, serverTimestamp } from 'firebase/firestore';\nimport { useAuth } from './AuthContext';\nimport { db } from '../services/firebase';\nimport { calculateWorkoutScore, calculateXPBonus } from '../utils/scoring';\nimport programsData from '../data/programs.json';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WorkoutContext = createContext({});\nexport const WorkoutProvider = ({\n  children\n}) => {\n  const [workoutData, setWorkoutData] = useState(null);\n  const [currentExerciseIndex, setCurrentExerciseIndex] = useState(0);\n  const [currentSetIndex, setCurrentSetIndex] = useState(0);\n  const [setsData, setSetsData] = useState([]);\n  const [isResting, setIsResting] = useState(false);\n  const [restTimeRemaining, setRestTimeRemaining] = useState(0);\n  const [workoutStartTime, setWorkoutStartTime] = useState(null);\n  const [restTimer, setRestTimer] = useState(null);\n  const {\n    user\n  } = useAuth();\n  const startWorkout = (program, level) => {\n    const workout = {\n      program,\n      level,\n      exercises: level.exercises\n    };\n    const initialSetsData = level.exercises.map(exercise => Array(exercise.sets).fill(0));\n    setWorkoutData(workout);\n    setCurrentExerciseIndex(0);\n    setCurrentSetIndex(0);\n    setSetsData(initialSetsData);\n    setIsResting(false);\n    setRestTimeRemaining(0);\n    setWorkoutStartTime(new Date());\n    if (restTimer) {\n      clearInterval(restTimer);\n      setRestTimer(null);\n    }\n  };\n  const recordSet = value => {\n    if (!workoutData) return;\n    const newSetsData = [...setsData];\n    newSetsData[currentExerciseIndex][currentSetIndex] = parseInt(value) || 0;\n    setSetsData(newSetsData);\n    const currentExercise = workoutData.exercises[currentExerciseIndex];\n    const isLastSet = currentSetIndex === currentExercise.sets - 1;\n    const isLastExercise = currentExerciseIndex === workoutData.exercises.length - 1;\n    if (isLastSet && isLastExercise) {\n      setCurrentExerciseIndex(currentExerciseIndex + 1);\n      completeWorkout(newSetsData);\n    } else if (isLastSet) {\n      setCurrentExerciseIndex(currentExerciseIndex + 1);\n      setCurrentSetIndex(0);\n    } else {\n      setCurrentSetIndex(currentSetIndex + 1);\n      startRest(currentExercise.rest);\n    }\n  };\n  const startRest = duration => {\n    setIsResting(true);\n    setRestTimeRemaining(duration);\n    const timer = setInterval(() => {\n      setRestTimeRemaining(prev => {\n        if (prev <= 1) {\n          clearInterval(timer);\n          setIsResting(false);\n          setRestTimer(null);\n          return 0;\n        }\n        return prev - 1;\n      });\n    }, 1000);\n    setRestTimer(timer);\n  };\n  const skipRest = () => {\n    if (restTimer) {\n      clearInterval(restTimer);\n      setRestTimer(null);\n    }\n    setIsResting(false);\n    setRestTimeRemaining(0);\n  };\n  const completeWorkout = async (finalSetsData = setsData) => {\n    if (!workoutData || !user?.uid) return;\n    try {\n      const exercisesCompleted = workoutData.exercises.map((exercise, index) => {\n        const setsResults = finalSetsData[index] || [];\n        const totalActual = setsResults.reduce((sum, val) => sum + val, 0);\n        const totalTarget = exercise.sets * exercise.target;\n        return {\n          exerciseId: exercise.id,\n          exerciseName: exercise.name,\n          type: exercise.type,\n          target: totalTarget,\n          actual: totalActual,\n          sets: setsResults\n        };\n      });\n      const {\n        score,\n        percentage\n      } = calculateWorkoutScore(exercisesCompleted);\n      const xpEarned = calculateXPBonus(score, workoutData.level.xpReward);\n      const workoutSession = {\n        userId: user.uid,\n        programId: workoutData.program.id,\n        levelId: workoutData.level.id,\n        exercises: exercisesCompleted,\n        score,\n        percentage,\n        xpEarned,\n        startTime: workoutStartTime,\n        endTime: new Date(),\n        createdAt: serverTimestamp()\n      };\n      const sessionRef = await addDoc(collection(db, 'workoutSessions'), workoutSession);\n      let levelCompleted = false;\n      let programCompleted = false;\n      let unlockedPrograms = [];\n      if (score >= 800) {\n        levelCompleted = true;\n        if (workoutData.level.id === 6) {\n          programCompleted = true;\n          const progressRef = doc(db, 'userProgress', `${user.uid}_${workoutData.program.id}`);\n          await updateDoc(progressRef, {\n            currentLevel: 7,\n            completedAt: serverTimestamp()\n          });\n          const userRef = doc(db, 'users', user.uid);\n          const userDoc = await getDoc(userRef);\n          const currentTotalXP = userDoc.data()?.totalXP || 0;\n          const currentCompletedPrograms = userDoc.data()?.totalCompletedPrograms || 0;\n          const bonusXP = 500;\n          await updateDoc(userRef, {\n            completedPrograms: arrayUnion(workoutData.program.id),\n            totalCompletedPrograms: currentCompletedPrograms + 1,\n            totalXP: currentTotalXP + xpEarned + bonusXP,\n            lastXPUpdate: serverTimestamp()\n          });\n          if (workoutData.program.unlocks && workoutData.program.unlocks.length > 0) {\n            for (const unlockedProgramId of workoutData.program.unlocks) {\n              try {\n                const unlockedProgressRef = doc(db, 'userProgress', `${user.uid}_${unlockedProgramId}`);\n                const existingProgress = await getDoc(unlockedProgressRef);\n                if (!existingProgress.exists()) {\n                  await setDoc(unlockedProgressRef, {\n                    userId: user.uid,\n                    programId: unlockedProgramId,\n                    currentLevel: 1,\n                    unlockedLevels: [1],\n                    completedLevels: [],\n                    totalSessions: 0,\n                    unlockedAt: serverTimestamp(),\n                    createdAt: serverTimestamp()\n                  });\n                  const unlockedProgram = programsData.programs.find(p => p.id === unlockedProgramId);\n                  if (unlockedProgram) {\n                    unlockedPrograms.push(unlockedProgram.name);\n                  }\n                }\n              } catch (unlockError) {\n                console.error(`Erreur déverrouillage programme ${unlockedProgramId}:`, unlockError);\n              }\n            }\n          }\n        } else {\n          await updateUserProgress(workoutData.program.id, workoutData.level.id);\n          await updateUserXP(xpEarned);\n        }\n      } else {\n        await updateUserXP(xpEarned);\n      }\n      return Object.assign({\n        sessionId: sessionRef.id,\n        score,\n        levelCompleted,\n        programCompleted,\n        unlockedPrograms\n      }, workoutSession);\n    } catch (error) {\n      console.error('Erreur sauvegarde séance:', error);\n      throw error;\n    }\n  };\n  const updateUserProgress = async (programId, completedLevelId) => {\n    try {\n      const progressRef = doc(db, 'userProgress', `${user.uid}_${programId}`);\n      const progressDoc = await getDoc(progressRef);\n      const currentProgress = progressDoc.data();\n      const newCompletedLevels = [...(currentProgress?.completedLevels || [])];\n      if (!newCompletedLevels.includes(completedLevelId)) {\n        newCompletedLevels.push(completedLevelId);\n      }\n      const newUnlockedLevels = [...(currentProgress?.unlockedLevels || [])];\n      const nextLevel = completedLevelId + 1;\n      if (nextLevel <= 6 && !newUnlockedLevels.includes(nextLevel)) {\n        newUnlockedLevels.push(nextLevel);\n      }\n      const newCurrentLevel = Math.max(currentProgress?.currentLevel || 1, nextLevel <= 6 ? nextLevel : completedLevelId);\n      await updateDoc(progressRef, {\n        currentLevel: newCurrentLevel,\n        unlockedLevels: newUnlockedLevels,\n        completedLevels: newCompletedLevels,\n        totalSessions: (currentProgress?.totalSessions || 0) + 1,\n        lastSessionAt: serverTimestamp()\n      });\n    } catch (error) {\n      console.error('Erreur mise à jour progression:', error);\n    }\n  };\n  const updateUserXP = async xpToAdd => {\n    try {\n      const userRef = doc(db, 'users', user.uid);\n      const userDoc = await getDoc(userRef);\n      const currentXP = userDoc.data()?.totalXP || 0;\n      await updateDoc(userRef, {\n        totalXP: currentXP + xpToAdd,\n        lastXPUpdate: serverTimestamp()\n      });\n    } catch (error) {\n      console.error('Erreur mise à jour XP:', error);\n    }\n  };\n  const resetWorkout = () => {\n    if (restTimer) {\n      clearInterval(restTimer);\n      setRestTimer(null);\n    }\n    setWorkoutData(null);\n    setCurrentExerciseIndex(0);\n    setCurrentSetIndex(0);\n    setSetsData([]);\n    setIsResting(false);\n    setRestTimeRemaining(0);\n    setWorkoutStartTime(null);\n  };\n  const getCurrentExercise = () => {\n    if (!workoutData || currentExerciseIndex >= workoutData.exercises.length) {\n      return null;\n    }\n    return workoutData.exercises[currentExerciseIndex];\n  };\n  const getCurrentSetNumber = () => {\n    return currentSetIndex + 1;\n  };\n  const getTotalSets = () => {\n    if (!workoutData) return 0;\n    return workoutData.exercises.reduce((total, exercise) => total + exercise.sets, 0);\n  };\n  const getCompletedSets = () => {\n    if (!workoutData) return 0;\n    let completed = 0;\n    for (let i = 0; i < currentExerciseIndex; i++) {\n      completed += workoutData.exercises[i].sets;\n    }\n    completed += currentSetIndex;\n    return completed;\n  };\n  const getProgressPercentage = () => {\n    const total = getTotalSets();\n    const completed = getCompletedSets();\n    return total > 0 ? completed / total * 100 : 0;\n  };\n  const value = {\n    workoutData,\n    currentExerciseIndex,\n    currentSetIndex,\n    setsData,\n    isResting,\n    restTimeRemaining,\n    workoutStartTime,\n    startWorkout,\n    recordSet,\n    startRest,\n    skipRest,\n    completeWorkout,\n    resetWorkout,\n    getCurrentExercise,\n    getCurrentSetNumber,\n    getTotalSets,\n    getCompletedSets,\n    getProgressPercentage\n  };\n  return _jsxDEV(WorkoutContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 406,\n    columnNumber: 5\n  }, this);\n};\nexport const useWorkout = () => {\n  const context = useContext(WorkoutContext);\n  if (!context) {\n    throw new Error('useWorkout must be used within a WorkoutProvider');\n  }\n  return context;\n};","map":{"version":3,"names":["React","createContext","useContext","useState","doc","addDoc","collection","updateDoc","getDoc","setDoc","arrayUnion","serverTimestamp","useAuth","db","calculateWorkoutScore","calculateXPBonus","programsData","jsxDEV","_jsxDEV","WorkoutContext","WorkoutProvider","children","workoutData","setWorkoutData","currentExerciseIndex","setCurrentExerciseIndex","currentSetIndex","setCurrentSetIndex","setsData","setSetsData","isResting","setIsResting","restTimeRemaining","setRestTimeRemaining","workoutStartTime","setWorkoutStartTime","restTimer","setRestTimer","user","startWorkout","program","level","workout","exercises","initialSetsData","map","exercise","Array","sets","fill","Date","clearInterval","recordSet","value","newSetsData","parseInt","currentExercise","isLastSet","isLastExercise","length","completeWorkout","startRest","rest","duration","timer","setInterval","prev","skipRest","finalSetsData","uid","exercisesCompleted","index","setsResults","totalActual","reduce","sum","val","totalTarget","target","exerciseId","id","exerciseName","name","type","actual","score","percentage","xpEarned","xpReward","workoutSession","userId","programId","levelId","startTime","endTime","createdAt","sessionRef","levelCompleted","programCompleted","unlockedPrograms","progressRef","currentLevel","completedAt","userRef","userDoc","currentTotalXP","data","totalXP","currentCompletedPrograms","totalCompletedPrograms","bonusXP","completedPrograms","lastXPUpdate","unlocks","unlockedProgramId","unlockedProgressRef","existingProgress","exists","unlockedLevels","completedLevels","totalSessions","unlockedAt","unlockedProgram","programs","find","p","push","unlockError","console","error","updateUserProgress","updateUserXP","Object","assign","sessionId","completedLevelId","progressDoc","currentProgress","newCompletedLevels","includes","newUnlockedLevels","nextLevel","newCurrentLevel","Math","max","lastSessionAt","xpToAdd","currentXP","resetWorkout","getCurrentExercise","getCurrentSetNumber","getTotalSets","total","getCompletedSets","completed","i","getProgressPercentage","Provider","fileName","_jsxFileName","lineNumber","columnNumber","useWorkout","context","Error"],"sources":["C:/Users/robin/Documents/RpgHybrid/src/contexts/WorkoutContext.js"],"sourcesContent":["import React, { createContext, useContext, useState } from 'react';\r\nimport { doc, addDoc, collection, updateDoc, getDoc, setDoc, arrayUnion, serverTimestamp } from 'firebase/firestore';\r\nimport { useAuth } from './AuthContext';\r\nimport { db } from '../services/firebase';\r\nimport { calculateWorkoutScore, calculateXPBonus } from '../utils/scoring';\r\nimport programsData from '../data/programs.json';\r\n\r\nconst WorkoutContext = createContext({});\r\n\r\nexport const WorkoutProvider = ({ children }) => {\r\n  // États de la séance\r\n  const [workoutData, setWorkoutData] = useState(null);\r\n  const [currentExerciseIndex, setCurrentExerciseIndex] = useState(0);\r\n  const [currentSetIndex, setCurrentSetIndex] = useState(0);\r\n  const [setsData, setSetsData] = useState([]); // Stocke les valeurs saisies\r\n  const [isResting, setIsResting] = useState(false);\r\n  const [restTimeRemaining, setRestTimeRemaining] = useState(0);\r\n  const [workoutStartTime, setWorkoutStartTime] = useState(null);\r\n  const [restTimer, setRestTimer] = useState(null);\r\n\r\n  const { user } = useAuth();\r\n\r\n  /**\r\n   * Démarre une nouvelle séance d'entraînement\r\n   */\r\n  const startWorkout = (program, level) => {\r\n    const workout = {\r\n      program,\r\n      level,\r\n      exercises: level.exercises\r\n    };\r\n\r\n    // Initialiser les données des séries\r\n    const initialSetsData = level.exercises.map(exercise => \r\n      Array(exercise.sets).fill(0)\r\n    );\r\n\r\n    setWorkoutData(workout);\r\n    setCurrentExerciseIndex(0);\r\n    setCurrentSetIndex(0);\r\n    setSetsData(initialSetsData);\r\n    setIsResting(false);\r\n    setRestTimeRemaining(0);\r\n    setWorkoutStartTime(new Date());\r\n    \r\n    // Clear any existing timer\r\n    if (restTimer) {\r\n      clearInterval(restTimer);\r\n      setRestTimer(null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Enregistre la valeur d'une série et passe à la suivante\r\n   */\r\n  const recordSet = (value) => {\r\n    if (!workoutData) return;\r\n\r\n    // Enregistrer la valeur\r\n    const newSetsData = [...setsData];\r\n    newSetsData[currentExerciseIndex][currentSetIndex] = parseInt(value) || 0;\r\n    setSetsData(newSetsData);\r\n\r\n    // Vérifier si c'est la dernière série de l'exercice\r\n    const currentExercise = workoutData.exercises[currentExerciseIndex];\r\n    const isLastSet = currentSetIndex === currentExercise.sets - 1;\r\n    const isLastExercise = currentExerciseIndex === workoutData.exercises.length - 1;\r\n\r\n    if (isLastSet && isLastExercise) {\r\n      // Séance terminée - passer à un index supérieur pour déclencher la navigation\r\n      setCurrentExerciseIndex(currentExerciseIndex + 1);\r\n      completeWorkout(newSetsData);\r\n    } else if (isLastSet) {\r\n      // Passer à l'exercice suivant\r\n      setCurrentExerciseIndex(currentExerciseIndex + 1);\r\n      setCurrentSetIndex(0);\r\n      // Pas de repos entre les exercices, on passe directement\r\n    } else {\r\n      // Passer à la série suivante et commencer le repos\r\n      setCurrentSetIndex(currentSetIndex + 1);\r\n      startRest(currentExercise.rest);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Démarre le timer de repos\r\n   */\r\n  const startRest = (duration) => {\r\n    setIsResting(true);\r\n    setRestTimeRemaining(duration);\r\n\r\n    const timer = setInterval(() => {\r\n      setRestTimeRemaining((prev) => {\r\n        if (prev <= 1) {\r\n          clearInterval(timer);\r\n          setIsResting(false);\r\n          setRestTimer(null);\r\n          return 0;\r\n        }\r\n        return prev - 1;\r\n      });\r\n    }, 1000);\r\n\r\n    setRestTimer(timer);\r\n  };\r\n\r\n  /**\r\n   * Skip le repos\r\n   */\r\n  const skipRest = () => {\r\n    if (restTimer) {\r\n      clearInterval(restTimer);\r\n      setRestTimer(null);\r\n    }\r\n    setIsResting(false);\r\n    setRestTimeRemaining(0);\r\n  };\r\n\r\n  /**\r\n   * Termine la séance et sauvegarde les données\r\n   */\r\n  const completeWorkout = async (finalSetsData = setsData) => {\r\n    if (!workoutData || !user?.uid) return;\r\n\r\n    try {\r\n      // Calculer le score\r\n      const exercisesCompleted = workoutData.exercises.map((exercise, index) => {\r\n        const setsResults = finalSetsData[index] || [];\r\n        const totalActual = setsResults.reduce((sum, val) => sum + val, 0);\r\n        const totalTarget = exercise.sets * exercise.target;\r\n\r\n        return {\r\n          exerciseId: exercise.id,\r\n          exerciseName: exercise.name,\r\n          type: exercise.type,\r\n          target: totalTarget,\r\n          actual: totalActual,\r\n          sets: setsResults\r\n        };\r\n      });\r\n\r\n      const { score, percentage } = calculateWorkoutScore(exercisesCompleted);\r\n      const xpEarned = calculateXPBonus(score, workoutData.level.xpReward);\r\n\r\n      // Créer la session de workout\r\n      const workoutSession = {\r\n        userId: user.uid,\r\n        programId: workoutData.program.id,\r\n        levelId: workoutData.level.id,\r\n        exercises: exercisesCompleted,\r\n        score,\r\n        percentage,\r\n        xpEarned,\r\n        startTime: workoutStartTime,\r\n        endTime: new Date(),\r\n        createdAt: serverTimestamp()\r\n      };\r\n\r\n      // Sauvegarder en Firestore\r\n      const sessionRef = await addDoc(collection(db, 'workoutSessions'), workoutSession);\r\n\r\n      let levelCompleted = false;\r\n      let programCompleted = false;\r\n      let unlockedPrograms = [];\r\n\r\n      // Mettre à jour la progression utilisateur si le niveau est validé\r\n      if (score >= 800) {\r\n        levelCompleted = true;\r\n        \r\n        // Vérifier si c'est le dernier niveau du programme (niveau 6) ET score validé\r\n        if (workoutData.level.id === 6) {\r\n          programCompleted = true;\r\n          \r\n          // 1. Marquer le programme comme terminé dans userProgress\r\n          const progressRef = doc(db, 'userProgress', `${user.uid}_${workoutData.program.id}`);\r\n          await updateDoc(progressRef, {\r\n            currentLevel: 7, // Indique que le programme est terminé\r\n            completedAt: serverTimestamp()\r\n          });\r\n\r\n          // 2. Mettre à jour le profil utilisateur\r\n          const userRef = doc(db, 'users', user.uid);\r\n          const userDoc = await getDoc(userRef);\r\n          const currentTotalXP = userDoc.data()?.totalXP || 0;\r\n          const currentCompletedPrograms = userDoc.data()?.totalCompletedPrograms || 0;\r\n          const bonusXP = 500; // XP bonus pour complétion de programme\r\n\r\n          await updateDoc(userRef, {\r\n            completedPrograms: arrayUnion(workoutData.program.id),\r\n            totalCompletedPrograms: currentCompletedPrograms + 1,\r\n            totalXP: currentTotalXP + xpEarned + bonusXP,\r\n            lastXPUpdate: serverTimestamp()\r\n          });\r\n\r\n          // 3. Débloquer les programmes suivants\r\n          if (workoutData.program.unlocks && workoutData.program.unlocks.length > 0) {\r\n            for (const unlockedProgramId of workoutData.program.unlocks) {\r\n              try {\r\n                // Créer un nouveau document de progression pour le programme débloqué\r\n                const unlockedProgressRef = doc(db, 'userProgress', `${user.uid}_${unlockedProgramId}`);\r\n                \r\n                // Vérifier si le document existe déjà\r\n                const existingProgress = await getDoc(unlockedProgressRef);\r\n                \r\n                if (!existingProgress.exists()) {\r\n                  await setDoc(unlockedProgressRef, {\r\n                    userId: user.uid,\r\n                    programId: unlockedProgramId,\r\n                    currentLevel: 1,\r\n                    unlockedLevels: [1],\r\n                    completedLevels: [],\r\n                    totalSessions: 0,\r\n                    unlockedAt: serverTimestamp(),\r\n                    createdAt: serverTimestamp()\r\n                  });\r\n\r\n                  // Trouver le nom du programme débloqué\r\n                  const unlockedProgram = programsData.programs.find(p => p.id === unlockedProgramId);\r\n                  if (unlockedProgram) {\r\n                    unlockedPrograms.push(unlockedProgram.name);\r\n                  }\r\n                }\r\n              } catch (unlockError) {\r\n                console.error(`Erreur déverrouillage programme ${unlockedProgramId}:`, unlockError);\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          // Juste un niveau validé parmi d'autres\r\n          await updateUserProgress(workoutData.program.id, workoutData.level.id);\r\n          // Mettre à jour les XP utilisateur\r\n          await updateUserXP(xpEarned);\r\n        }\r\n      } else {\r\n        // Niveau non validé, juste mettre à jour les XP\r\n        await updateUserXP(xpEarned);\r\n      }\r\n\r\n      return {\r\n        sessionId: sessionRef.id,\r\n        score,\r\n        levelCompleted,\r\n        programCompleted,\r\n        unlockedPrograms,\r\n        ...workoutSession\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Erreur sauvegarde séance:', error);\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Met à jour la progression utilisateur\r\n   */\r\n  const updateUserProgress = async (programId, completedLevelId) => {\r\n    try {\r\n      const progressRef = doc(db, 'userProgress', `${user.uid}_${programId}`);\r\n      \r\n      // Charger la progression actuelle\r\n      const progressDoc = await getDoc(progressRef);\r\n      const currentProgress = progressDoc.data();\r\n      \r\n      const newCompletedLevels = [...(currentProgress?.completedLevels || [])];\r\n      if (!newCompletedLevels.includes(completedLevelId)) {\r\n        newCompletedLevels.push(completedLevelId);\r\n      }\r\n\r\n      const newUnlockedLevels = [...(currentProgress?.unlockedLevels || [])];\r\n      const nextLevel = completedLevelId + 1;\r\n      if (nextLevel <= 6 && !newUnlockedLevels.includes(nextLevel)) {\r\n        newUnlockedLevels.push(nextLevel);\r\n      }\r\n\r\n      const newCurrentLevel = Math.max(\r\n        currentProgress?.currentLevel || 1,\r\n        nextLevel <= 6 ? nextLevel : completedLevelId\r\n      );\r\n\r\n      await updateDoc(progressRef, {\r\n        currentLevel: newCurrentLevel,\r\n        unlockedLevels: newUnlockedLevels,\r\n        completedLevels: newCompletedLevels,\r\n        totalSessions: (currentProgress?.totalSessions || 0) + 1,\r\n        lastSessionAt: serverTimestamp()\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Erreur mise à jour progression:', error);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Met à jour les XP de l'utilisateur\r\n   */\r\n  const updateUserXP = async (xpToAdd) => {\r\n    try {\r\n      const userRef = doc(db, 'users', user.uid);\r\n      const userDoc = await getDoc(userRef);\r\n      const currentXP = userDoc.data()?.totalXP || 0;\r\n\r\n      await updateDoc(userRef, {\r\n        totalXP: currentXP + xpToAdd,\r\n        lastXPUpdate: serverTimestamp()\r\n      });\r\n    } catch (error) {\r\n      console.error('Erreur mise à jour XP:', error);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Réinitialise la séance\r\n   */\r\n  const resetWorkout = () => {\r\n    if (restTimer) {\r\n      clearInterval(restTimer);\r\n      setRestTimer(null);\r\n    }\r\n    \r\n    setWorkoutData(null);\r\n    setCurrentExerciseIndex(0);\r\n    setCurrentSetIndex(0);\r\n    setSetsData([]);\r\n    setIsResting(false);\r\n    setRestTimeRemaining(0);\r\n    setWorkoutStartTime(null);\r\n  };\r\n\r\n  /**\r\n   * Obtient l'exercice actuel\r\n   */\r\n  const getCurrentExercise = () => {\r\n    if (!workoutData || currentExerciseIndex >= workoutData.exercises.length) {\r\n      return null;\r\n    }\r\n    return workoutData.exercises[currentExerciseIndex];\r\n  };\r\n\r\n  /**\r\n   * Obtient le numéro de la série actuelle (1-indexed)\r\n   */\r\n  const getCurrentSetNumber = () => {\r\n    return currentSetIndex + 1;\r\n  };\r\n\r\n  /**\r\n   * Obtient le total des séries dans la séance\r\n   */\r\n  const getTotalSets = () => {\r\n    if (!workoutData) return 0;\r\n    return workoutData.exercises.reduce((total, exercise) => total + exercise.sets, 0);\r\n  };\r\n\r\n  /**\r\n   * Obtient le nombre de séries complétées\r\n   */\r\n  const getCompletedSets = () => {\r\n    if (!workoutData) return 0;\r\n    \r\n    let completed = 0;\r\n    for (let i = 0; i < currentExerciseIndex; i++) {\r\n      completed += workoutData.exercises[i].sets;\r\n    }\r\n    completed += currentSetIndex;\r\n    \r\n    return completed;\r\n  };\r\n\r\n  /**\r\n   * Calcule le pourcentage de progression\r\n   */\r\n  const getProgressPercentage = () => {\r\n    const total = getTotalSets();\r\n    const completed = getCompletedSets();\r\n    return total > 0 ? (completed / total) * 100 : 0;\r\n  };\r\n\r\n  const value = {\r\n    // États\r\n    workoutData,\r\n    currentExerciseIndex,\r\n    currentSetIndex,\r\n    setsData,\r\n    isResting,\r\n    restTimeRemaining,\r\n    workoutStartTime,\r\n\r\n    // Fonctions\r\n    startWorkout,\r\n    recordSet,\r\n    startRest,\r\n    skipRest,\r\n    completeWorkout,\r\n    resetWorkout,\r\n\r\n    // Helpers\r\n    getCurrentExercise,\r\n    getCurrentSetNumber,\r\n    getTotalSets,\r\n    getCompletedSets,\r\n    getProgressPercentage\r\n  };\r\n\r\n  return (\r\n    <WorkoutContext.Provider value={value}>\r\n      {children}\r\n    </WorkoutContext.Provider>\r\n  );\r\n};\r\n\r\n/**\r\n * Hook personnalisé pour accéder au contexte de workout\r\n */\r\nexport const useWorkout = () => {\r\n  const context = useContext(WorkoutContext);\r\n  if (!context) {\r\n    throw new Error('useWorkout must be used within a WorkoutProvider');\r\n  }\r\n  return context;\r\n};\r\n"],"mappings":";AAAA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,UAAU,EAAEC,QAAQ,QAAQ,OAAO;AAClE,SAASC,GAAG,EAAEC,MAAM,EAAEC,UAAU,EAAEC,SAAS,EAAEC,MAAM,EAAEC,MAAM,EAAEC,UAAU,EAAEC,eAAe,QAAQ,oBAAoB;AACpH,SAASC,OAAO,QAAQ,eAAe;AACvC,SAASC,EAAE,QAAQ,sBAAsB;AACzC,SAASC,qBAAqB,EAAEC,gBAAgB,QAAQ,kBAAkB;AAC1E,OAAOC,YAAY,MAAM,uBAAuB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEjD,MAAMC,cAAc,GAAGlB,aAAa,CAAC,CAAC,CAAC,CAAC;AAExC,OAAO,MAAMmB,eAAe,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAE/C,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGpB,QAAQ,CAAC,IAAI,CAAC;EACpD,MAAM,CAACqB,oBAAoB,EAAEC,uBAAuB,CAAC,GAAGtB,QAAQ,CAAC,CAAC,CAAC;EACnE,MAAM,CAACuB,eAAe,EAAEC,kBAAkB,CAAC,GAAGxB,QAAQ,CAAC,CAAC,CAAC;EACzD,MAAM,CAACyB,QAAQ,EAAEC,WAAW,CAAC,GAAG1B,QAAQ,CAAC,EAAE,CAAC;EAC5C,MAAM,CAAC2B,SAAS,EAAEC,YAAY,CAAC,GAAG5B,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAAC6B,iBAAiB,EAAEC,oBAAoB,CAAC,GAAG9B,QAAQ,CAAC,CAAC,CAAC;EAC7D,MAAM,CAAC+B,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGhC,QAAQ,CAAC,IAAI,CAAC;EAC9D,MAAM,CAACiC,SAAS,EAAEC,YAAY,CAAC,GAAGlC,QAAQ,CAAC,IAAI,CAAC;EAEhD,MAAM;IAAEmC;EAAK,CAAC,GAAG1B,OAAO,CAAC,CAAC;EAK1B,MAAM2B,YAAY,GAAGA,CAACC,OAAO,EAAEC,KAAK,KAAK;IACvC,MAAMC,OAAO,GAAG;MACdF,OAAO;MACPC,KAAK;MACLE,SAAS,EAAEF,KAAK,CAACE;IACnB,CAAC;IAGD,MAAMC,eAAe,GAAGH,KAAK,CAACE,SAAS,CAACE,GAAG,CAACC,QAAQ,IAClDC,KAAK,CAACD,QAAQ,CAACE,IAAI,CAAC,CAACC,IAAI,CAAC,CAAC,CAC7B,CAAC;IAED1B,cAAc,CAACmB,OAAO,CAAC;IACvBjB,uBAAuB,CAAC,CAAC,CAAC;IAC1BE,kBAAkB,CAAC,CAAC,CAAC;IACrBE,WAAW,CAACe,eAAe,CAAC;IAC5Bb,YAAY,CAAC,KAAK,CAAC;IACnBE,oBAAoB,CAAC,CAAC,CAAC;IACvBE,mBAAmB,CAAC,IAAIe,IAAI,CAAC,CAAC,CAAC;IAG/B,IAAId,SAAS,EAAE;MACbe,aAAa,CAACf,SAAS,CAAC;MACxBC,YAAY,CAAC,IAAI,CAAC;IACpB;EACF,CAAC;EAKD,MAAMe,SAAS,GAAIC,KAAK,IAAK;IAC3B,IAAI,CAAC/B,WAAW,EAAE;IAGlB,MAAMgC,WAAW,GAAG,CAAC,GAAG1B,QAAQ,CAAC;IACjC0B,WAAW,CAAC9B,oBAAoB,CAAC,CAACE,eAAe,CAAC,GAAG6B,QAAQ,CAACF,KAAK,CAAC,IAAI,CAAC;IACzExB,WAAW,CAACyB,WAAW,CAAC;IAGxB,MAAME,eAAe,GAAGlC,WAAW,CAACqB,SAAS,CAACnB,oBAAoB,CAAC;IACnE,MAAMiC,SAAS,GAAG/B,eAAe,KAAK8B,eAAe,CAACR,IAAI,GAAG,CAAC;IAC9D,MAAMU,cAAc,GAAGlC,oBAAoB,KAAKF,WAAW,CAACqB,SAAS,CAACgB,MAAM,GAAG,CAAC;IAEhF,IAAIF,SAAS,IAAIC,cAAc,EAAE;MAE/BjC,uBAAuB,CAACD,oBAAoB,GAAG,CAAC,CAAC;MACjDoC,eAAe,CAACN,WAAW,CAAC;IAC9B,CAAC,MAAM,IAAIG,SAAS,EAAE;MAEpBhC,uBAAuB,CAACD,oBAAoB,GAAG,CAAC,CAAC;MACjDG,kBAAkB,CAAC,CAAC,CAAC;IAEvB,CAAC,MAAM;MAELA,kBAAkB,CAACD,eAAe,GAAG,CAAC,CAAC;MACvCmC,SAAS,CAACL,eAAe,CAACM,IAAI,CAAC;IACjC;EACF,CAAC;EAKD,MAAMD,SAAS,GAAIE,QAAQ,IAAK;IAC9BhC,YAAY,CAAC,IAAI,CAAC;IAClBE,oBAAoB,CAAC8B,QAAQ,CAAC;IAE9B,MAAMC,KAAK,GAAGC,WAAW,CAAC,MAAM;MAC9BhC,oBAAoB,CAAEiC,IAAI,IAAK;QAC7B,IAAIA,IAAI,IAAI,CAAC,EAAE;UACbf,aAAa,CAACa,KAAK,CAAC;UACpBjC,YAAY,CAAC,KAAK,CAAC;UACnBM,YAAY,CAAC,IAAI,CAAC;UAClB,OAAO,CAAC;QACV;QACA,OAAO6B,IAAI,GAAG,CAAC;MACjB,CAAC,CAAC;IACJ,CAAC,EAAE,IAAI,CAAC;IAER7B,YAAY,CAAC2B,KAAK,CAAC;EACrB,CAAC;EAKD,MAAMG,QAAQ,GAAGA,CAAA,KAAM;IACrB,IAAI/B,SAAS,EAAE;MACbe,aAAa,CAACf,SAAS,CAAC;MACxBC,YAAY,CAAC,IAAI,CAAC;IACpB;IACAN,YAAY,CAAC,KAAK,CAAC;IACnBE,oBAAoB,CAAC,CAAC,CAAC;EACzB,CAAC;EAKD,MAAM2B,eAAe,GAAG,MAAAA,CAAOQ,aAAa,GAAGxC,QAAQ,KAAK;IAC1D,IAAI,CAACN,WAAW,IAAI,CAACgB,IAAI,EAAE+B,GAAG,EAAE;IAEhC,IAAI;MAEF,MAAMC,kBAAkB,GAAGhD,WAAW,CAACqB,SAAS,CAACE,GAAG,CAAC,CAACC,QAAQ,EAAEyB,KAAK,KAAK;QACxE,MAAMC,WAAW,GAAGJ,aAAa,CAACG,KAAK,CAAC,IAAI,EAAE;QAC9C,MAAME,WAAW,GAAGD,WAAW,CAACE,MAAM,CAAC,CAACC,GAAG,EAAEC,GAAG,KAAKD,GAAG,GAAGC,GAAG,EAAE,CAAC,CAAC;QAClE,MAAMC,WAAW,GAAG/B,QAAQ,CAACE,IAAI,GAAGF,QAAQ,CAACgC,MAAM;QAEnD,OAAO;UACLC,UAAU,EAAEjC,QAAQ,CAACkC,EAAE;UACvBC,YAAY,EAAEnC,QAAQ,CAACoC,IAAI;UAC3BC,IAAI,EAAErC,QAAQ,CAACqC,IAAI;UACnBL,MAAM,EAAED,WAAW;UACnBO,MAAM,EAAEX,WAAW;UACnBzB,IAAI,EAAEwB;QACR,CAAC;MACH,CAAC,CAAC;MAEF,MAAM;QAAEa,KAAK;QAAEC;MAAW,CAAC,GAAGxE,qBAAqB,CAACwD,kBAAkB,CAAC;MACvE,MAAMiB,QAAQ,GAAGxE,gBAAgB,CAACsE,KAAK,EAAE/D,WAAW,CAACmB,KAAK,CAAC+C,QAAQ,CAAC;MAGpE,MAAMC,cAAc,GAAG;QACrBC,MAAM,EAAEpD,IAAI,CAAC+B,GAAG;QAChBsB,SAAS,EAAErE,WAAW,CAACkB,OAAO,CAACwC,EAAE;QACjCY,OAAO,EAAEtE,WAAW,CAACmB,KAAK,CAACuC,EAAE;QAC7BrC,SAAS,EAAE2B,kBAAkB;QAC7Be,KAAK;QACLC,UAAU;QACVC,QAAQ;QACRM,SAAS,EAAE3D,gBAAgB;QAC3B4D,OAAO,EAAE,IAAI5C,IAAI,CAAC,CAAC;QACnB6C,SAAS,EAAEpF,eAAe,CAAC;MAC7B,CAAC;MAGD,MAAMqF,UAAU,GAAG,MAAM3F,MAAM,CAACC,UAAU,CAACO,EAAE,EAAE,iBAAiB,CAAC,EAAE4E,cAAc,CAAC;MAElF,IAAIQ,cAAc,GAAG,KAAK;MAC1B,IAAIC,gBAAgB,GAAG,KAAK;MAC5B,IAAIC,gBAAgB,GAAG,EAAE;MAGzB,IAAId,KAAK,IAAI,GAAG,EAAE;QAChBY,cAAc,GAAG,IAAI;QAGrB,IAAI3E,WAAW,CAACmB,KAAK,CAACuC,EAAE,KAAK,CAAC,EAAE;UAC9BkB,gBAAgB,GAAG,IAAI;UAGvB,MAAME,WAAW,GAAGhG,GAAG,CAACS,EAAE,EAAE,cAAc,EAAE,GAAGyB,IAAI,CAAC+B,GAAG,IAAI/C,WAAW,CAACkB,OAAO,CAACwC,EAAE,EAAE,CAAC;UACpF,MAAMzE,SAAS,CAAC6F,WAAW,EAAE;YAC3BC,YAAY,EAAE,CAAC;YACfC,WAAW,EAAE3F,eAAe,CAAC;UAC/B,CAAC,CAAC;UAGF,MAAM4F,OAAO,GAAGnG,GAAG,CAACS,EAAE,EAAE,OAAO,EAAEyB,IAAI,CAAC+B,GAAG,CAAC;UAC1C,MAAMmC,OAAO,GAAG,MAAMhG,MAAM,CAAC+F,OAAO,CAAC;UACrC,MAAME,cAAc,GAAGD,OAAO,CAACE,IAAI,CAAC,CAAC,EAAEC,OAAO,IAAI,CAAC;UACnD,MAAMC,wBAAwB,GAAGJ,OAAO,CAACE,IAAI,CAAC,CAAC,EAAEG,sBAAsB,IAAI,CAAC;UAC5E,MAAMC,OAAO,GAAG,GAAG;UAEnB,MAAMvG,SAAS,CAACgG,OAAO,EAAE;YACvBQ,iBAAiB,EAAErG,UAAU,CAACY,WAAW,CAACkB,OAAO,CAACwC,EAAE,CAAC;YACrD6B,sBAAsB,EAAED,wBAAwB,GAAG,CAAC;YACpDD,OAAO,EAAEF,cAAc,GAAGlB,QAAQ,GAAGuB,OAAO;YAC5CE,YAAY,EAAErG,eAAe,CAAC;UAChC,CAAC,CAAC;UAGF,IAAIW,WAAW,CAACkB,OAAO,CAACyE,OAAO,IAAI3F,WAAW,CAACkB,OAAO,CAACyE,OAAO,CAACtD,MAAM,GAAG,CAAC,EAAE;YACzE,KAAK,MAAMuD,iBAAiB,IAAI5F,WAAW,CAACkB,OAAO,CAACyE,OAAO,EAAE;cAC3D,IAAI;gBAEF,MAAME,mBAAmB,GAAG/G,GAAG,CAACS,EAAE,EAAE,cAAc,EAAE,GAAGyB,IAAI,CAAC+B,GAAG,IAAI6C,iBAAiB,EAAE,CAAC;gBAGvF,MAAME,gBAAgB,GAAG,MAAM5G,MAAM,CAAC2G,mBAAmB,CAAC;gBAE1D,IAAI,CAACC,gBAAgB,CAACC,MAAM,CAAC,CAAC,EAAE;kBAC9B,MAAM5G,MAAM,CAAC0G,mBAAmB,EAAE;oBAChCzB,MAAM,EAAEpD,IAAI,CAAC+B,GAAG;oBAChBsB,SAAS,EAAEuB,iBAAiB;oBAC5Bb,YAAY,EAAE,CAAC;oBACfiB,cAAc,EAAE,CAAC,CAAC,CAAC;oBACnBC,eAAe,EAAE,EAAE;oBACnBC,aAAa,EAAE,CAAC;oBAChBC,UAAU,EAAE9G,eAAe,CAAC,CAAC;oBAC7BoF,SAAS,EAAEpF,eAAe,CAAC;kBAC7B,CAAC,CAAC;kBAGF,MAAM+G,eAAe,GAAG1G,YAAY,CAAC2G,QAAQ,CAACC,IAAI,CAACC,CAAC,IAAIA,CAAC,CAAC7C,EAAE,KAAKkC,iBAAiB,CAAC;kBACnF,IAAIQ,eAAe,EAAE;oBACnBvB,gBAAgB,CAAC2B,IAAI,CAACJ,eAAe,CAACxC,IAAI,CAAC;kBAC7C;gBACF;cACF,CAAC,CAAC,OAAO6C,WAAW,EAAE;gBACpBC,OAAO,CAACC,KAAK,CAAC,mCAAmCf,iBAAiB,GAAG,EAAEa,WAAW,CAAC;cACrF;YACF;UACF;QACF,CAAC,MAAM;UAEL,MAAMG,kBAAkB,CAAC5G,WAAW,CAACkB,OAAO,CAACwC,EAAE,EAAE1D,WAAW,CAACmB,KAAK,CAACuC,EAAE,CAAC;UAEtE,MAAMmD,YAAY,CAAC5C,QAAQ,CAAC;QAC9B;MACF,CAAC,MAAM;QAEL,MAAM4C,YAAY,CAAC5C,QAAQ,CAAC;MAC9B;MAEA,OAAA6C,MAAA,CAAAC,MAAA;QACEC,SAAS,EAAEtC,UAAU,CAAChB,EAAE;QACxBK,KAAK;QACLY,cAAc;QACdC,gBAAgB;QAChBC;MAAgB,GACbV,cAAc;IAGrB,CAAC,CAAC,OAAOwC,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;MACjD,MAAMA,KAAK;IACb;EACF,CAAC;EAKD,MAAMC,kBAAkB,GAAG,MAAAA,CAAOvC,SAAS,EAAE4C,gBAAgB,KAAK;IAChE,IAAI;MACF,MAAMnC,WAAW,GAAGhG,GAAG,CAACS,EAAE,EAAE,cAAc,EAAE,GAAGyB,IAAI,CAAC+B,GAAG,IAAIsB,SAAS,EAAE,CAAC;MAGvE,MAAM6C,WAAW,GAAG,MAAMhI,MAAM,CAAC4F,WAAW,CAAC;MAC7C,MAAMqC,eAAe,GAAGD,WAAW,CAAC9B,IAAI,CAAC,CAAC;MAE1C,MAAMgC,kBAAkB,GAAG,CAAC,IAAID,eAAe,EAAElB,eAAe,IAAI,EAAE,CAAC,CAAC;MACxE,IAAI,CAACmB,kBAAkB,CAACC,QAAQ,CAACJ,gBAAgB,CAAC,EAAE;QAClDG,kBAAkB,CAACZ,IAAI,CAACS,gBAAgB,CAAC;MAC3C;MAEA,MAAMK,iBAAiB,GAAG,CAAC,IAAIH,eAAe,EAAEnB,cAAc,IAAI,EAAE,CAAC,CAAC;MACtE,MAAMuB,SAAS,GAAGN,gBAAgB,GAAG,CAAC;MACtC,IAAIM,SAAS,IAAI,CAAC,IAAI,CAACD,iBAAiB,CAACD,QAAQ,CAACE,SAAS,CAAC,EAAE;QAC5DD,iBAAiB,CAACd,IAAI,CAACe,SAAS,CAAC;MACnC;MAEA,MAAMC,eAAe,GAAGC,IAAI,CAACC,GAAG,CAC9BP,eAAe,EAAEpC,YAAY,IAAI,CAAC,EAClCwC,SAAS,IAAI,CAAC,GAAGA,SAAS,GAAGN,gBAC/B,CAAC;MAED,MAAMhI,SAAS,CAAC6F,WAAW,EAAE;QAC3BC,YAAY,EAAEyC,eAAe;QAC7BxB,cAAc,EAAEsB,iBAAiB;QACjCrB,eAAe,EAAEmB,kBAAkB;QACnClB,aAAa,EAAE,CAACiB,eAAe,EAAEjB,aAAa,IAAI,CAAC,IAAI,CAAC;QACxDyB,aAAa,EAAEtI,eAAe,CAAC;MACjC,CAAC,CAAC;IAEJ,CAAC,CAAC,OAAOsH,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;IACzD;EACF,CAAC;EAKD,MAAME,YAAY,GAAG,MAAOe,OAAO,IAAK;IACtC,IAAI;MACF,MAAM3C,OAAO,GAAGnG,GAAG,CAACS,EAAE,EAAE,OAAO,EAAEyB,IAAI,CAAC+B,GAAG,CAAC;MAC1C,MAAMmC,OAAO,GAAG,MAAMhG,MAAM,CAAC+F,OAAO,CAAC;MACrC,MAAM4C,SAAS,GAAG3C,OAAO,CAACE,IAAI,CAAC,CAAC,EAAEC,OAAO,IAAI,CAAC;MAE9C,MAAMpG,SAAS,CAACgG,OAAO,EAAE;QACvBI,OAAO,EAAEwC,SAAS,GAAGD,OAAO;QAC5BlC,YAAY,EAAErG,eAAe,CAAC;MAChC,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOsH,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;IAChD;EACF,CAAC;EAKD,MAAMmB,YAAY,GAAGA,CAAA,KAAM;IACzB,IAAIhH,SAAS,EAAE;MACbe,aAAa,CAACf,SAAS,CAAC;MACxBC,YAAY,CAAC,IAAI,CAAC;IACpB;IAEAd,cAAc,CAAC,IAAI,CAAC;IACpBE,uBAAuB,CAAC,CAAC,CAAC;IAC1BE,kBAAkB,CAAC,CAAC,CAAC;IACrBE,WAAW,CAAC,EAAE,CAAC;IACfE,YAAY,CAAC,KAAK,CAAC;IACnBE,oBAAoB,CAAC,CAAC,CAAC;IACvBE,mBAAmB,CAAC,IAAI,CAAC;EAC3B,CAAC;EAKD,MAAMkH,kBAAkB,GAAGA,CAAA,KAAM;IAC/B,IAAI,CAAC/H,WAAW,IAAIE,oBAAoB,IAAIF,WAAW,CAACqB,SAAS,CAACgB,MAAM,EAAE;MACxE,OAAO,IAAI;IACb;IACA,OAAOrC,WAAW,CAACqB,SAAS,CAACnB,oBAAoB,CAAC;EACpD,CAAC;EAKD,MAAM8H,mBAAmB,GAAGA,CAAA,KAAM;IAChC,OAAO5H,eAAe,GAAG,CAAC;EAC5B,CAAC;EAKD,MAAM6H,YAAY,GAAGA,CAAA,KAAM;IACzB,IAAI,CAACjI,WAAW,EAAE,OAAO,CAAC;IAC1B,OAAOA,WAAW,CAACqB,SAAS,CAAC+B,MAAM,CAAC,CAAC8E,KAAK,EAAE1G,QAAQ,KAAK0G,KAAK,GAAG1G,QAAQ,CAACE,IAAI,EAAE,CAAC,CAAC;EACpF,CAAC;EAKD,MAAMyG,gBAAgB,GAAGA,CAAA,KAAM;IAC7B,IAAI,CAACnI,WAAW,EAAE,OAAO,CAAC;IAE1B,IAAIoI,SAAS,GAAG,CAAC;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnI,oBAAoB,EAAEmI,CAAC,EAAE,EAAE;MAC7CD,SAAS,IAAIpI,WAAW,CAACqB,SAAS,CAACgH,CAAC,CAAC,CAAC3G,IAAI;IAC5C;IACA0G,SAAS,IAAIhI,eAAe;IAE5B,OAAOgI,SAAS;EAClB,CAAC;EAKD,MAAME,qBAAqB,GAAGA,CAAA,KAAM;IAClC,MAAMJ,KAAK,GAAGD,YAAY,CAAC,CAAC;IAC5B,MAAMG,SAAS,GAAGD,gBAAgB,CAAC,CAAC;IACpC,OAAOD,KAAK,GAAG,CAAC,GAAIE,SAAS,GAAGF,KAAK,GAAI,GAAG,GAAG,CAAC;EAClD,CAAC;EAED,MAAMnG,KAAK,GAAG;IAEZ/B,WAAW;IACXE,oBAAoB;IACpBE,eAAe;IACfE,QAAQ;IACRE,SAAS;IACTE,iBAAiB;IACjBE,gBAAgB;IAGhBK,YAAY;IACZa,SAAS;IACTS,SAAS;IACTM,QAAQ;IACRP,eAAe;IACfwF,YAAY;IAGZC,kBAAkB;IAClBC,mBAAmB;IACnBC,YAAY;IACZE,gBAAgB;IAChBG;EACF,CAAC;EAED,OACE1I,OAAA,CAACC,cAAc,CAAC0I,QAAQ;IAACxG,KAAK,EAAEA,KAAM;IAAAhC,QAAA,EACnCA;EAAQ;IAAAyI,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACc,CAAC;AAE9B,CAAC;AAKD,OAAO,MAAMC,UAAU,GAAGA,CAAA,KAAM;EAC9B,MAAMC,OAAO,GAAGjK,UAAU,CAACiB,cAAc,CAAC;EAC1C,IAAI,CAACgJ,OAAO,EAAE;IACZ,MAAM,IAAIC,KAAK,CAAC,kDAAkD,CAAC;EACrE;EACA,OAAOD,OAAO;AAChB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}